----------CLI-GIT-VCS----------

What are Linux commands and can you give some examples that you use?
- Linux commands are instructions that you can give to a computer running the Linux operating system
- They allows us to perform various tasks, like managing files, folders, and programs
Some exmaples:
    - pwd: use this command to check which directory you're working on.
    - cd: use this command to open the specified directory-navigate to the specfied directory
    - cd..: use this command to mogve up to the parent directory-navigate to the parent directory 
    - cd/: use this command to move up to the starting directory-root directory
    - cd ~: use this command to move to the home directory 
    - clear: use this command to clear working terminal or command prompt
    - mkdir: use this command to create a new directory 
    - rmdir: use this command to remove and existing empty directory
    - touch: use this command to create a new file 
    - echo content > fileName: use this command to create a new file with an intial text. 

What is GIT vs VCS?
- GIT (Global Information Tracker) is the name of the version control sytem (VCS)
- GIT is a software for tracking changes in any set of filesm and usually for coordinating work among programmers to collaboratively develop the source code.
- Version Control System Types: 
    1. Centralized: one central server and mnay users
    2. Distributed: local repositories added for each user 

Centralized Version Control System:
- There is a central server that stores the entire history of the projectm inclduing all the files and their versions
- Developers check out a copy of the project from the central server to work on it 
- Common examples include CVS (Concurrent Versions System) and Subversion (SVN)
Advantages: 
- Centralized control and management 
- Easy access control and permissions 
- Users can work offline but commits require network access
Disadvantages:
- Single point of failure (if the central server goes down, work is disputed)
- Slower performance for certain operations 
- Limited branching and merging capabilities 

Distributed Version Control System
- Each developer has a complete copy of the project, including the entire history, on their local machine 
- Developers can work independently and commit changes to their local copy without needing constant network access
- Changes can be synchronized and merged with other Developers' copies when needed 
- Common examples include Git, Mercurialm and Bazaar
Advantages:
- No single point of failure (no central server dependecy)
- Gaster performance, especially for common operations 
- String branching and merging capabilities 
- offline work is seamless 
Disadvantages:
- Can be more complex to set up and manage, especially for large projects 

What are the differences between GIT and hosting platforms like GitHub?
- GIT is a software for tracking changes in any set of files and usually used for coordinating work among programmers to collaboratively develop the source code 
- GIT is an open-source tool that allows 
    - team members to collaborate 
    - track and revert changes 
- GitHub is a platform where developers store their projects as repositories and have additional features to help them collaborate to develop projects 
- Similar hosting websites: GitLab, BitBucket 

What is SSH Key? 
    - An SSH key, is the context of services like GitHub, GitLab, and BitBucket, is a secure and convenient way to authenticate and establish a secure connection between your local development environment (your computer) and the remote repository hosted on one of these platforms 
    - SSH kets are an alternative to using a username and password for authentication, and they offer several benefits 
        - Security: SSH kets are more secure than passwords because they are cryptographically generated and provide a stronger level of protection against unauthorized access
        - Convenience: Once set up, you dont need to enter your password each time you interact with a remote repository. It simplifies the authentication process 
        - Automation: SSH keys are essential for automated proccess, such as continuous integration and deployment (CI/CD) pipelines, which require secure, passwordless authentication

What is GIT branching? 
    - Git branching is a fundamental concept in GIT, and itplays a cruical role in managing and organzing your codebase 
    - It allows us to create a separate line of development, known as a branch, from the main codebase (often reffered to as the "master" or "main" branch)
    - Each branch can have its own set of changes, features, or bug fixes, while the main branch remains stable 

What are some GIT commands you use?
    - git branch: list the existing branches 
    - git branch <branch-name>: create a new branch with the specified name 
    - git branch -m <new-branch-name>: rename the branch with the specified new name 
    - git checkout -b <branch-name>: create and switch to the created branch
    - git branch -d <branch-name>: delete the specified branch
    - git merge <branch-name>: merge changes from the specified branch (first time push)
    - git push: push changes from an existing branch (already pushed before at least once)
    - git pull: fetch changes from the remote repository including the main/master branch 

What is a Pull Request?
    - A pull request - also referred to as a merge request - is known as a contributer/developer is ready to begin the process of merging new code changes with the main project repository
    - It is basically after you are done with your changes on your own branch, you request your changes to be merged with main remote branch 
    - Steps to create a Pull Request
    - Do your changes in a repository with your own branch 
    - Push your code to your remote branch 
    - Go to hosting website 
    - Create a pull request from your branch to main branch (add reviwers id requreed as a policy)
    - After PR is created, your reviwer (if you add any) or yourself can merge the code to the main branch (master)

What is merge conflict and how to resolve it? 
    - This is a common issue when multiple people work on the same project 
    - A merge conflict occurs when Git is unable to automatically merge two branches because they have competing changes 
    - It occurs when multiple people make changes on the same file 
    - We need to resolve this conflict before merging it to main branch (master)
To Resolve a merge conflict, follow these steps: 
    - Checkout the branch: first, make sure you are on the branch where the conflict needs to be resolved. You can do this using <git checkout branch-name>
    - Pull the latest changes: Its a good practice to ensure your branh is up to date with the latest changes from the remote repository by runing git pull . 
    - Locate and Open the conflict file: Git will indicate the conflicted files. Open the file(s) in a text editor 
    - Review the conflict: Inside the file,  Git will mark the conflicting lines with special markers such as <<<<<<<, =======, and >>>>>>>. These markers separate the conflicting changes. Review the conflicting sections to understand what each contributor intended.
    - Manually Resolve the Conflict: Edit the file to retain the changes you want to keep and remove the markers. This may involve combining, rewriting, or discarding code as needed.
    - Save the File: After resolving the conflict, save the file. 
    - Add and Commit the Changes: Use git add conflicted-file to stage the resolved file, and then commit the changes using git commit.
Push the Changes: If you resolved the conflict while working on a branch with a corresponding 
Pull Request, push the changes to the remote repository using git push. 

----------Soft Skills----------

Software Development Life Cycle 

What is SDLC? 
    - SDLC stands for Software Development Life Cycle, which is a systematic process for planning, designing, developing, testing, deploying, and maintaining software applications
    - The primary objective of SDLC is to ensure that the software product meets the desired quality and functionality requirements

What are the stages of SDLC? 
    there are typically six main stages in SDLC:
        A. Requirement Gathering & Analysis (planning)
        B. Design 
        C. Implementation/Development
        D. Testing 
        E. Deployment 
        F. Maintenance 

What is the purpose of each stage in SDLC? 
    A. Requirement Gathering & Analysis: To collect and analyze the clients requirements and establish the projects scope 
    B. Design: To create a detailed system and software deisgn based on the requirements
    C. Implementation/Development: To build the softwre on the clients systems.
    D. Testing: To identify and fix defects in the software and ensure it meets the requirements
    E. Deployment: To deliver and install the software on the clients systems
    F. Maintenance: To provide ongoing support, enhancements, and updates to the software 

A. Requirement Gatherign Analysis:
    - During this stage, the project team collaborates with stakeholders, such as clients, end-users, and subject matter experts, to gather and analyze their requirements.
    - This involves understanding the business processes, user needs, and constraints of the proposed software solution.
    - The output of this stage is typically a Software Requirements Specification (SRS) document, which serves as a foundation for the subsequent stages of the SDLC.

B. Design:
    - In the deisgn stagem the project team created detailed plans for the software system, including its architecture, user interfaces, data structures, and algorithms 
    - This involves translating the requirements gathered in the previous stage into a coherent and feasible design. 
    - The oupt of this stage includes design documents, such as high-level and low-level design Specifications, that guide the development process.

C. Implementation/Development:
    - During the Implementation stage, the software developers write the actual code for the application, follwoing the design specifications
    - They utilize programming languages, frameworks, and tools to build the software components and integrate them into a functional system 
    - The ouput of this stage is a working software product that is ready for testing 

D. Testing:
    - The testing stage involves veryifying and validating the software prouct to ensure it meets the specified requirements and its free from defects 
    - This inclides various types of testing, such as unit testing, integration testing, system testingm and user acceptance testing (UAT)
    - Testers create test plans, test cases and test scripts to systematically indentify and fix issues in the software 
    - The output of this stage is stable, high-qualify software product that is ready for deployment

e) Deployment: 
•  During the deployment stage, the software product is installed and configured on the 
client's systems or the target environment.  
•  This may involve setting up the necessary infrastructure, such as servers and 
databases, as well as training end-users on how to use the software.  
•  The output of this stage is a fully operational software product that is accessible to its 
intended users. 
f) Maintenance: 
•  The maintenance stage is an ongoing process that begins after the software has been 
deployed.  
•  It involves providing support to end-users, addressing issues and bugs that may arise, 
and updating the software to accommodate new requirements or changes in the 
environment.  
•  Maintenance also includes enhancing the software with new features, optimizing its 
performance, and ensuring compatibility with evolving technologies.  
•  The output of this stage is a continually improved and updated software product that 
meets the needs of its users over time. 
 www.techglobalschool.com 
 
  6 
Can you describe the different roles and responsibilities involved 
in SDLC process? 
Customer: 
•  Responsibilities: 
o  Define business objectives and requirements. 
o  Provide feedback and review deliverables. 
o  Approve changes and project milestones. 
Product Owner (PO) / Business Analyst (BA): 
•  Responsibilities: 
o  Define and prioritize product backlog items. 
o  Act as the liaison between the development team and stakeholders. 
o  Ensure the team works on the highest-priority tasks. 
Scrum Master: 
•  Responsibilities: 
o  Facilitate Scrum ceremonies (stand-ups, sprint planning, retrospectives). 
o  Remove impediments and ensure team productivity. 
o  Shield the team from external distractions. 
Software Architect: 
•  Responsibilities: 
o  Define system architecture and design. 
o  Create technical specifications and design documents. 
o  Ensure the system is scalable, maintainable, and secure. 
o  Coordinate with development teams. 
Software Developer: 
•  Responsibilities: 
o  Write code based on technical specifications. 
o  Debug and troubleshoot software issues. 
o  Collaborate with the testing team. 
o  Follow coding standards and best practices. 
Software Tester: 
•  Responsibilities: 
o  Develop test plans and test cases. 
o  Execute functional, integration, and regression tests. 
o  Report and track defects. 
o  Ensure software meets quality standards. 
 www.techglobalschool.com 
 
  7 
UX Designer / UI Designer: 
•  Responsibilities: 
o  Design user interfaces and user experiences. 
o  Create wireframes, mockups, and prototypes. 
o  Ensure a user-friendly and visually appealing interface. 
End User: 
•  Responsibilities: 
o  Use the software for all their needs. 
o  Work with UI and UX Designers for testing purposes. 
o  Report any bugs during maintenance phase. 
 
Project Management Methodologies 
What is Agile and Waterfall, and how do they differ? 
•  Agile and Waterfall are two distinct software development methodologies, each with its 
own approach to project management, collaboration, and workflow.  
•  NOTE: A project management methodology is a set of principles and practices that 
guide you in organizing your projects to ensure their optimum performance. 
Agile: 
•  Agile is an iterative and flexible methodology that emphasizes collaboration, adaptability, 
and customer feedback throughout the development process. 
•  It involves breaking a project into smaller increments, known as iterations or sprints, with 
each delivering a potentially shippable product increment. 
•  Agile values customer involvement welcomes changes even late in the development 
cycle, and focuses on delivering value to the customer early and consistently. 
•  Popular Agile frameworks include Scrum and Kanban. 
Waterfall: 
•  Waterfall is a linear and sequential approach where each phase of the project must be 
completed before moving on to the next. 
•  It follows a predefined project plan with distinct phases, such as requirements gathering, 
design, development, testing, and deployment, in that order. 
•  Waterfall is often used for projects with well-defined requirements and limited changes 
expected during development. 
•  Changes in Waterfall can be costly and challenging to accommodate once a phase is 
completed. 
 www.techglobalschool.com 
 
  8 
Key Differences: 
•  Approach: Agile is iterative and incremental, allowing for changes and customer 
feedback throughout the project, while Waterfall follows a strict, linear sequence. 
•  Flexibility: Agile is highly flexible and adaptive to changes, whereas Waterfall is less 
accommodating to changes once a phase is completed. 
•  Customer Involvement: Agile encourages ongoing customer involvement and 
feedback, whereas Waterfall typically involves customers in the initial phase but has less 
ongoing interaction. 
•  Project Delivery: Agile delivers increments of a product throughout the project, enabling 
early value delivery, while Waterfall delivers the complete product at the end of the 
project. 
•  Risk Management: Agile provides better risk management through frequent inspections 
and adaptability, while Waterfall may have higher risks if requirements are not well-
defined. 
 
What is the main difference between Scrum and Kanban? 
Scrum: 
•  Structured framework with defined roles, ceremonies, and artifacts. 
•  Work is organized into fixed-length iterations (sprints). 
•  Defines specific roles (Scrum Master, Product Owner, Development Team). 
•  Relies on estimation (e.g., story points) for capacity planning. 
•  Discourages changes to sprint scope once it begins. 
Kanban: 
•  Flexible methodology without predefined roles or ceremonies. 
•  Work is pulled from a backlog as capacity allows no fixed iterations. 
•  No specific roles defined, promotes self-organization. 
•  Minimal upfront estimation: work items are pulled without rigid estimation. 
•  Embraces change and adapts to new priorities at any time. 
Simply, Scrum is fixed with 2–4-week sprints and every team member are assigned with specific 
tasks to complete in the same sprint and it has meetings to synchronize team members while 
Kanban is not time-boxed and flexible. Team member in Kanban can take a new task whenever 
they finish the current tasks. 
 
 
 
 
 
 www.techglobalschool.com 
 
  9 
SCRUM - Roles & Ceremonies 
Can you explain the Scrum framework and its key components, 
such as the Scrum Master, Product Owner, and Development 
Team? 
•  Scrum is an Agile framework that breaks down large projects into smaller, manageable 
increments called sprints.  
•  The key components are the Scrum Master, Product Owner, and Development Team.  
•  The Scrum Master facilitates the Scrum process, removes impediments, and ensures 
the team follows the agreed-upon practices.  
•  The Product Owner defines the product vision, prioritizes the backlog, and represents 
the stakeholders.  
•  The Development Team is responsible for delivering potentially shippable increments at 
the end of each sprint. 
 
How does Scrum differ from other Agile methodologies? 
•  Scrum is an Agile framework that emphasizes teamwork, accountability, and iterative 
progress towards a common goal.  
•  It differs from other Agile methodologies in that it places a heavy emphasis on regular 
communication and collaboration between team members, as well as on frequent 
inspection and adaptation of the product and the process. 
 
How do you differentiate between a project manager and a 
product owner in Agile methodology? 
•  In Agile, a project manager focuses on managing the project timeline, resources, and 
budget, ensuring that the team delivers the project as planned.  
•  A product owner, on the other hand, is responsible for defining the product vision, 
prioritizing the backlog, and ensuring that the team delivers value to the end-users and 
stakeholders. 
 
What are the Scrum ceremonies, artifacts, and roles? 
•  The Scrum framework consists of several ceremonies, artifacts, and roles.  
•  Ceremonies include the Sprint Planning, Daily Scrum, Sprint Review, and Sprint 
Retrospective.  
•  Artifacts include the Product Backlog, Sprint Backlog, and Increment.  
•  Roles include the Product Owner, Scrum Master, and Development Team. 
 www.techglobalschool.com 
 
  10 
What is Epic and who is responsible for creating and managing 
Epics? 
•  Definition: An Epic in JIRA represents a large and high-level body of work that can be 
broken down into smaller, more manageable pieces of work called User Stories. 
•  Responsibility: Epics are typically created and managed by the Product Owner or a 
person responsible for defining high-level project objectives. Development teams may 
also contribute to Epic refinement. 
 
What is User Story and who is responsible for creating and 
managing User Stories? 
•  Definition: A User Story is a smaller, more detailed piece of work that describes a single 
piece of functionality from an end user's perspective. User Stories are often used to 
describe the features or functionality that make up an Epic. 
•  Responsibility: User Stories are typically created and managed by the Development 
Team and the Product Owner collaboratively. Development teams often provide 
estimates for User Stories during sprint planning. 
 
What are acceptance criteria? 
•  Definition: Acceptance Criteria are specific conditions or requirements that must be met 
for a User Story to be considered complete. They serve as a definition of "done" for the 
story. 
•  Responsibility: Acceptance Criteria are defined collaboratively by the Development 
Team and the Product Owner. They ensure a shared understanding of what it means for 
a User Story to be finished. 
 
Can you explain the difference between a product backlog and a 
sprint backlog? 
•  The product backlog contains all the features, enhancements, and bug fixes that the 
team plans to deliver over the course of the product development.  
•  The sprint backlog is a subset of the product backlog and contains only the items that 
the team commits to delivering during the upcoming sprint. 
 
 
 
 www.techglobalschool.com 
 
  11 
How do you prioritize items in the Product Backlog, and what 
factors should be considered? 
•  Prioritization of Product Backlog items is typically based on factors such as business 
value, risk, dependencies, and technical complexity.  
•  Companies use different techniques for prioritization. 
 
How do Product Backlog, Sprint Backlog, and Increment 
contribute to the Scrum framework? 
•  The Product Backlog drives the product's evolution and helps the Scrum Team 
understand what needs to be done.  
•  The Sprint Backlog provides a clear plan for the current Sprint and ensures that the team 
focuses on the highest priority items.  
•  The Increment represents the progress made during each Sprint and serves as a 
foundation for continuous improvement. 
 
What is a Sprint? 
•  A sprint is a time-boxed iteration in Agile project management and development.  
•  It is a fundamental concept within Agile methodologies, particularly in Scrum.  
•  Sprints provide a structured framework for teams to work on a defined set of tasks or 
User Stories within a fixed time, typically ranging from one to four weeks, with two weeks 
being the most common duration. 
 
What is a Sprint Goal, and how does it relate to the Sprint 
Backlog? 
•  A Sprint Goal is a short, high-level description of the desired outcome for a Sprint.  
•  It provides a shared understanding of the Sprint's purpose and guides the team in 
selecting and prioritizing the Product Backlog items for the Sprint Backlog. 
 
What is Burndown Chart? 
•  A burndown chart is a graphical representation used in Agile project management, 
particularly in Scrum, to visualize and track the progress of work during a sprint or an 
iteration.  
•  It helps teams monitor whether they are on track to complete their planned work within 
the defined timeframe. 
 
 www.techglobalschool.com 
 
  12 
Scrum Artifacts and Other Meetings 
What are the three primary Scrum artifacts, and what is the 
purpose of each? 
•  The three primary Scrum artifacts are the Product Backlog, Sprint Backlog, and 
Increment.  
•  The Product Backlog is a prioritized list of features, enhancements, and fixes that are 
planned for the product.  
•  The Sprint Backlog contains the selected Product Backlog items for the current Sprint 
and the plan to deliver them.  
•  The Increment is the sum of all completed Product Backlog items in a Sprint, resulting in 
a potentially releasable product. 
 
What are Scrum Ceremonies? 
•  Scrum ceremonies are essential events or meetings in the Scrum framework, an Agile 
project management methodology.  
•  These ceremonies help teams work together efficiently, maintain transparency, and 
adapt to changing requirements.  
•  There are several Scrum ceremonies, each serving a specific purpose within the Scrum 
framework: 
o  Sprint Planning: This ceremony marks the start of each sprint.  
§  The team selects User Stories or tasks from the product backlog and 
decides what can be accomplished during the sprint.  
§  The outcome of this ceremony is the sprint backlog, a list of items to be 
worked on during the sprint. 
o  Daily Stand-up (Daily Scrum): This is a short, daily meeting where team 
members share progress updates, discuss challenges, and plan for the day.  
§  It promotes collaboration and ensures everyone is aligned on the work. 
§  Questions: What did you do yesterday? What will you do today? Any 
impediments? 
o  Sprint Review (DEMO): At the end of each sprint, the team conducts a sprint 
review to demonstrate the completed work to stakeholders and gather feedback.  
§  It provides an opportunity to inspect the increment and make decisions 
about the product's future. 
o  Sprint Retrospective: Following the sprint review, the team holds a 
retrospective meeting.  
§  In this meeting, team members reflect on the sprint, discuss what went 
well and what could be improved, and identify actions for continuous 
improvement. 
o  Backlog Refinement (Grooming): This is not a single event but a continuous 
process.  
 www.techglobalschool.com 
 
  13 
§  It involves regularly reviewing and updating the product backlog, clarifying 
User Stories, and ensuring that items are well-defined and prioritized for 
future sprints. 
 
Can you explain the process of refining the Product Backlog, and 
how does the Scrum Team ensure that items are "Ready" for an 
upcoming Sprint? 
•  Refining the Product Backlog involves adding detail, estimating effort, and prioritizing 
items.  
•  The Scrum Team collaborates on this process, ensuring that items are clear, actionable, 
and appropriately sized. An item is considered "Ready" when it meets the team's 
Definition of Ready, which typically includes having clear acceptance criteria, 
dependencies resolved, and a reasonable estimate of effort. 
•  Estimation: To estimate the effort required to complete each backlog item, often 
using techniques like story points or time-based estimates. 
 
What is the definition of "Done" in Scrum, and how does it impact 
the Increment? 
•  The Definition of Done (DoD) is a shared understanding of the criteria that a Product 
Backlog item must meet to be considered complete.  
•  The DoD ensures consistent quality and provides a clear goal for each Increment.  
•  An Increment is considered potentially releasable when all its items meet the DoD. 
 
What is Three-Amigos Meeting? 
•  The 3-Amigos Meeting is a collaborative and informal meeting that typically involves 
three key roles in Agile development: 
o  Business Analyst or Product Owner: Represents the business or customer 
perspective and provides information about the desired functionality and user 
requirements. 
o  Developer: Represents the technical perspective and can clarify how the 
functionality will be implemented from a technical standpoint. 
o  Tester: Represents the quality assurance perspective and focuses on 
understanding how the functionality will be tested and validated. 
•  The purpose of the 3-Amigos Meeting is to foster shared understanding and 
collaboration among these three essential roles.  
•  During the meeting, they review and discuss User Stories or features to ensure that they 
are well-defined, feasible, and testable.  
 www.techglobalschool.com 
 
  14 
•  This collaboration helps identify potential issues or ambiguities early in the development 
process, reducing the likelihood of misunderstandings, rework, and defects. 
•  Key elements of a 3-Amigos Meeting include: 
o  Reviewing User Stories or requirements. 
o  Asking questions and seeking clarification. 
o  Discussing technical considerations. 
o  Defining acceptance criteria. 
o  Exploring potential test scenarios. 
 
What is Parking Lot Meeting? 
•  A Parking Lot Meeting is a term often used in project management, particularly in Agile 
and Scrum environments.  
•  It refers to a meeting or discussion where team members or stakeholders set aside 
topics or issues that are not directly related to the current agenda or sprint but need to 
be addressed in the future. 
 
Software Testing Life Cycle 
What is STLC? 
•  STLC is a fundamental part of the Software Development Life Cycle (SDLC), but STLC 
consists of only the testing phases. 
•  STLC starts as soon as requirements are defined, or software requirement document is 
shared by stakeholders. 
•  STLC yields a step-by-step process to ensure quality software. 
•  In the initial stages of STLC, while the software product or the application is being 
developed, the testing team analyzes and defines the scope of testing, entry and exit 
criteria, and also test cases.  
•  It helps to reduce the test cycle time and also enhances product quality.  
•  As soon as the development phase is over, the testing team is ready with test cases and 
starts the execution.  
•  This helps in finding bugs in the early phase.  
 
What are the stages of STLC? 
There are typically six main stages in STLC: 
a) Requirement Analysis  
b) Test Planning 
c) Test Case Development 
d) Test Environment Setup 
 www.techglobalschool.com 
 
  15 
e) Test Execution 
f) Test Cycle Closure 
 
What is the purpose of each stage in STLC? 
a) Requirement Analysis: Analyze project requirements to understand what needs to be 
tested. They identify testable requirements and create a test plan. 
b) Test Planning: Develop a comprehensive test strategy and plan. This plan outlines the 
testing scope, objectives, resources, schedule, and test environment requirements. It also 
defines the test techniques and methods to be used. 
c) Test Case Development: Test cases and test scripts are created based on the requirements 
and test plan. Test data, if necessary, is also prepared. The goal is to ensure that testing covers 
all aspects of the software's functionality. 
d) Test Environment Setup: The test environment, which includes hardware, software, 
network configurations, and test tools, is set up to simulate the production environment in which 
the software will be used. 
e) Test Execution: Testers execute the test cases in the specified test environment. They 
record test results, report defects, and monitor the testing process to ensure that it follows the 
test plan. 
f) Test Cycle Closure: Close the testing activities. It includes evaluating whether the testing 
goals and objectives have been met, archiving test assets, and conducting a review to identify 
process improvements. 
 
a) Requirement Analysis  
•  Requirement Analysis is the first step of the Software Testing Life Cycle (STLC).  
•  In this phase quality assurance team understands the requirements like what is to be 
tested. If anything is missing or not understandable then the quality assurance team 
meets with the stakeholders to better understand the detailed knowledge of 
requirements.                   
•  The activities that take place during the Requirement Analysis stage include: 
o  Reviewing the software requirements document (SRD) and other related 
documents 
o  Identifying any ambiguities or inconsistencies in the requirements 
o  Identifying any missing or incomplete requirements 
o  Identifying any potential risks or issues that may impact the testing process. 
o  Creating a requirement traceability matrix (RTM) to map requirements to test 
cases. 
•  At the end of this stage, the testing team should have a clear understanding of the 
software requirements and should have identified any potential issues that may impact 
the testing process.  
•  This will help to ensure that the testing process is focused on the most important areas 
of the software and that the testing team is able to deliver high-quality results. 
 
 
 
 www.techglobalschool.com 
 
  16 
b) Test Planning 
•  Test Planning is the most efficient phase of the software testing life cycle where all 
testing plans are defined.  
•  In this phase manager of the testing team calculates the estimated effort and cost for the 
testing work.  
•  This phase gets started once the requirement-gathering phase is completed. 
•  The activities that take place during the Test Planning stage include: 
o  Identifying the testing objectives and scope 
o  Developing a test strategy 
o  Identifying the testing environment and resources needed 
o  Identifying the test cases that will be executed and the test data that will be used 
o  Assigning roles and responsibilities to the testing team 
o  Reviewing and approving the test plan 
•  At the end of this stage, the testing team should have a detailed plan for the testing 
activities that will be performed, and a clear understanding of the testing objectives, 
scope, and deliverables.  
•  This will help to ensure that the testing process is well-organized and that the testing 
team is able to deliver high-quality results. 
 
c) Test Case Development 
•  The test case development phase gets started once the test planning phase is 
completed. 
•  In this phase testing team notes down the detailed test cases.  
•  The testing team also prepares the required test data for the testing.  
•  When the test cases are prepared then they are reviewed by the quality assurance 
team. 
•  The activities that take place during the Test Case Development stage include: 
o  Identifying the test cases that will be developed 
o  Writing test cases that are clear, concise, and easy to understand 
o  Creating test data and test scenarios that will be used in the test cases 
o  Identifying the expected results for each test case 
o  Reviewing and validating the test cases 
o  Updating the requirement traceability matrix (RTM) to map requirements to test 
cases 
•  At the end of this stage, the testing team should have a set of comprehensive and 
accurate test cases that provide adequate coverage of the software or application.  
•  This will help to ensure that the testing process is thorough and that any potential issues 
are identified and addressed before the software is released. 
 
d) Test Environment Setup 
•  Test environment setup is a vital part of the STLC.  
•  Basically, the test environment decides the conditions on which software is tested.  
•  This is independent activity and can be started along with test case development.  
•  In this process, the testing team is not involved.  
•  Either the developer or the customer creates the testing environment. 
 
 
 www.techglobalschool.com 
 
  17 
e) Test Execution 
•  After the test case development and test environment setup test execution phase gets 
started.  
•  In this phase testing team starts executing test cases based on prepared test cases in 
the earlier step. 
•  The activities that take place during the test execution stage of the Software Testing Life 
Cycle (STLC) include: 
o  Test data is prepared and loaded into the system for test execution 
o  The test cases and scripts created in the test design stage are run against the 
software application to identify any defects or issues. 
o  The results of the test execution are analyzed to determine the software’s 
performance and identify any defects or issues. 
o  Any defects or issues that are found during test execution are logged in a defect 
tracking system, along with details such as the severity, priority, and description 
of the issue. 
o  Any defects that are identified during test execution are retested to ensure that 
they have been fixed correctly. 
o  Test results are documented and reported to the relevant stakeholders. 
•  It is important to note that test execution is an iterative process and may need to be 
repeated multiple times until all identified defects are fixed and the software is deemed fit 
for release. 
 
f) Test Cycle Closure 
•  Test closure is the final stage of the Software Testing Life Cycle (STLC) where all 
testing-related activities are completed and documented.  
•  The main objective of the test closure stage is to ensure that all testing-related activities 
have been completed and that the software is ready for release. 
•  At the end of the test closure stage, the testing team should have a clear understanding 
of the software’s quality and reliability, and any defects or issues that were identified 
during testing should have been resolved.  
•  The test closure stage also includes documenting the testing process and any lessons 
learned so that they can be used to improve future testing processes. 
•  Test closure is the final stage of the Software Testing Life Cycle (STLC) where all 
testing-related activities are completed and documented. 
•  It is important to note that test closure is not just about documenting the testing process, 
but also about ensuring that all relevant information is shared, and any lessons learned 
are captured for future reference. The goal of test closure is to ensure that the software 
is ready for release and that the testing process has been conducted in an organized 
and efficient manner. 
 
  18 
Bug Life Cycle 
What is a Bug and who creates a Bug ticket? 
•  Definition: A Bug/Defect represents an issue or problem in the software that needs to 
be addressed and fixed.  
o  Bugs can be identified during testing or by end users. 
•  Responsibility: Anyone on the team can create a Bug ticket, but it's often testers or 
quality assurance professionals who identify and report them.  
•  The responsibility for fixing the Bug typically falls on the Development Team. 
 
What is Bug Life Cycle? 
•  The Bug Life Cycle, also known as the Defect Life Cycle, is a systematic process that 
describes the various stages a software defect or bug goes through, from its 
identification to its resolution.  
•  The Bug Life Cycle is an integral part of software testing and quality assurance, ensuring 
that identified defects are properly managed and tracked throughout their lifecycle.  
•  The specific stages of the Bug Life Cycle can vary depending on the organization and 
the issue-tracking system in use, but the following are common stages: 
o  New: This is the initial stage, where a tester or team member identifies and 
reports a defect. At this point, the bug is labeled as "New" and enters the tracking 
system. 
o  Assigned: Once a bug is reported, it is assigned to the appropriate team or 
individual responsible for its resolution, typically a developer or development 
team. The bug's status is updated to "Assigned." 
o  Open: When the developer begins working on the bug, the status is changed to 
"Open." This indicates that the issue is actively being addressed. 
o  In Progress: The bug may be further classified as "In Progress" to signify that 
development or code changes are actively being made to fix the issue. 
o  Fixed: After the developer believes they have resolved the bug, they mark it as 
"Fixed." The fix is typically committed to the code repository. 
o  Ready for Testing: In this stage, the issue is handed over to the testing team. 
Testers verify the fix and validate whether the bug has been successfully 
addressed. 
o  Reopened: If the testing team finds that the issue still exists or the bug is not 
completely resolved, they mark it as "Reopened" and provide additional details 
on why the issue persists. 
o  Retest: The developer makes further fixes to the bug based on the testing team's 
feedback. After these changes, the issue is marked for retesting. 
o  Verified: Once the testing team confirms that the issue has been successfully 
fixed and no longer exists in the software, they change the bug's status to 
"Verified." 

 
  19 
o  Closed: The final stage is "Closed." This indicates that the bug has been 
resolved and validated. It is now considered officially closed, and the issue-
tracking system is updated accordingly. 
 
What needs to be included in a Bug ticket? 
•  A clear and concise summary of the issue. 
•  A detailed description of the problem, including steps to reproduce. 
•  Priority and severity levels. 
•  Attachments (screenshots, logs, etc.) for better understanding. 
•  Information on the environment where the issue was found. 
 
What is the difference between priority vs severity of a bug? 
1.  Severity: 
a.  Definition: Severity refers to the impact or seriousness of a bug on the 
software's functionality and end-users. 
b.  Focus: It assesses how critical the bug is in terms of its potential to cause harm 
or disruption to the system and its users. 
c.  Classification: Severity is typically categorized into levels such as "Critical," 
"Major," "Minor," and "Cosmetic" to indicate the bug's impact on the application. 
d.  Example: A bug that causes a system crash would have a "Critical" severity, 
while a minor cosmetic issue like a typo might have a "Minor" severity. 
2.  Priority: 
a.  Definition: Priority indicates the order in which a bug should be fixed or 
addressed based on factors like business needs, deadlines, and resource 
availability. 
b.  Focus: It considers how soon the issue needs to be resolved and the urgency of 
the fix. 
c.  Classification: Priority levels can range from "Immediate" or "Urgent" for issues 
that require immediate attention to "Low" for less critical issues that can be 
addressed later. 
d.  Example: Even though a bug may have a "Critical" severity, it might have a 
"Medium" priority if it doesn't need an immediate fix because it doesn't impact 
critical business processes. 
 
Why do we need Bug Tracking Tools? 
•  Bug tracking tools (e.g., Jira, Bugzilla) play a crucial role in managing the bug life cycle. 
•  These tools help teams track, prioritize, and communicate about bugs. 
 
 
  20 
Test Cases  
What is a Test Case and what are Test Case components? 
•  Test cases are detailed steps that testers follow to verify the functionality of a user story. 
•  They include preconditions, actions, expected results, and sometimes, test data. 
•  They help testers systematically assess whether the software behaves as intended and 
meets the defined requirements. 
•  Components of a Test Case: A typical test case comprises several components: 
o  Test Case ID: A unique identifier for the test case. 
o  Test Case Title/Name: A descriptive title or name that provides an overview of 
the test case's purpose. 
o  Test Objective: A brief description of the test case's objective, including what it 
aims to test or achieve. 
o  Preconditions: Conditions or requirements that must be satisfied before the test 
case can be executed. 
o  Test Steps: A step-by-step sequence of actions or interactions to be performed 
to execute the test. This includes input data, specific operations, and expected 
outcomes. 
o  Expected Results: The anticipated results, including what the software should 
display or how it should behave after the test case is executed. 
o  Actual Results: A space to record the actual outcomes observed during test 
execution. 
o  Status: The current status of the test case, which may be "Pass," "Fail," "Not 
Executed," or similar. 
 
What are differences between Test Scenario, Test Case and Test 
Script? 
•  Test Scenario: A test scenario is a high-level test objective or goal.  
o  For example, a test scenario might be "User should be able to login,". 
•  Test Case: A test case is a detailed set of instructions specifying a single test scenario, 
including the specific inputs, actions, and expected outcomes. 
•  Test Script: A test script is a set of executable instructions or code used for automated 
testing. Test scripts are often derived from test cases and are used to automate the 
execution of test cases. 
 
 
  21 
What are the benefits of writing Test Cases? 
•  Test cases ensures that all relevant scenarios are considered. 
•  Test cases allow testers to reproduce specific scenarios consistently. 
•  Test cases help testers work more efficiently by providing clear instructions. 
•  Test cases can uncover defects early in the development process. 
•  Test cases help trace test coverage back to specific requirements. 
 
What are positive and negative Test Cases? 
•  Positive Test Cases: These test cases validate that the software behaves correctly 
under normal or expected conditions. They confirm that the software meets its functional 
requirements. 
o  For a login system, a positive test case would be when a user enters the correct 
username and password and successfully logs into the application. 
•  Negative Test Cases: Negative test cases are designed to check how the software 
handles unexpected or incorrect inputs or scenarios. They aim to expose flaws or 
vulnerabilities in the software. 
o  In the same login system, a negative test case would be when a user enters an 
incorrect password and receives an error message indicating a failed login 
attempt. 
What is Happy Path Testing? 
•  Happy Path Testing is a testing approach that focuses on testing a software application 
under normal and expected conditions.  
•  It involves executing positive test cases to ensure that the software follows the intended 
flow and functions correctly when everything goes well. 
 
What is Boundary or Edge Test Cases? 
•  Boundary or Edge Test Cases involve testing the limits of software functionality, 
including the boundary conditions or the extreme values of input data.  
•  They are designed to identify issues related to data validation, range, and limits. 
•  Examples; 
o  If a system requires a minimum password length of 8 characters, a boundary test 
case would involve testing with a password of exactly 8 characters to ensure it's 
accepted. 
o  In a file upload feature, if the maximum allowed file size is 10 MB, boundary 
testing would involve attempting to upload a file that is exactly 10 MB to verify it's 
accepted. 
o  If a numerical input field has a valid range of 1 to 100, boundary tests would 
include entering the values 1 and 100 to check if both are accepted. 
 www.techglobalschool.com 
 
  22 
o  In a text input field, if the maximum character limit is 100 characters, a boundary 
test case would include entering exactly 100 characters to verify they are 
accepted. 
o  If a website has an age verification process, testing would include entering an 
age just below and just above the legal age limit to confirm that it allows or 
denies access appropriately. 
 
What is Requirement Traceability Matrix (RTM)? 
•  A Requirement Traceability Matrix (RTM) is a structured document that serves as a 
critical link between the requirements of a software project and the corresponding test 
cases designed to verify or validate those requirements. 
•  The RTM helps ensure that each requirement is adequately tested, and it provides a 
clear understanding of which requirements have been covered by testing. 
 
Software Testing Types 
What is Software Testing and what are the different types of 
Software Testing? 
•  Software Testing is a process of evaluating a software application to find defects and 
ensure its quality.  
•  There are various types of software testing, including Functional Testing, Non-functional 
Testing (Performance, Security, etc.), Manual Testing, Automated Testing, and more.  
 
What are white-box and black-box testing? Give some examples. 
•  White-box testing involves examining the internal structure and code of the software. 
Testers need knowledge of the code to design test cases.  
•  Black-box testing, on the other hand, focuses on testing the software's functionality 
without knowledge of its internal code.  
•  Examples of white-box testing include Unit Testing and Code Review.  
•  Examples of black-box testing include Functional Testing and User Acceptance Testing. 

 
What is Unit Testing and Integration Testing and what are their 
differences? 
•  Unit Testing checks individual components or functions of the software in isolation.  
•  Integration Testing verifies how these components work together.  
•  Unit Testing focuses on small units, while Integration Testing ensures that the integrated 
parts function correctly as a whole. 
•  Unit Testing is performed by developers while Integration Testing is performed by 
testers. 
 
What is Smoke Testing and Regression Testing and what are 
their differences? 
•  Smoke Testing is a quick check to ensure that the most critical functions of the software 
work after changes or new features are added.  
•  Regression Testing, on the other hand, retests the entire application to ensure that new 
changes have not affected existing functionalities.  
 
What is Sanity Testing and when to perform it? 
•  Sanity Testing is a narrow form of regression testing.  
•  It checks specific areas of the software that were modified or fixed after a defect is 
found. 
•  It's performed when minor changes are made to ensure that those changes haven't 
introduced new issues. 
 
What is Performance Testing and why is it needed? What are 
different types of Performance Testing? 
•  Performance Testing assesses the software's speed, responsiveness, and stability 
under different conditions.  
•  It's needed to ensure that the software meets performance requirements.  
•  Types of Performance Testing include Load Testing, Stress Testing, Spike Testing, 
Endurance Testing and Scalability Testing, among others. 
 
 
  24 
What is End-to-End Testing and what are the benefits it provides? 
•  End-to-End Testing checks the entire flow of a software application, from start to finish, 
including all interconnected components.  
•  It verifies the software's readiness for real-world usage and ensures that all parts work 
together. 
 
What is User Acceptance Testing (UAT) and when to perform it? 
•  User Acceptance Testing (UAT) is conducted by end-users to ensure that the software 
meets their requirements and works as intended.  
•  It's performed in the final stages of testing, just before the software's release. 
 
What is Alpha Testing and Beta Testing and who performs them? 
•  Alpha Testing is conducted by the development team within the organization.  
•  Beta Testing is performed by external users or customers.  
•  Both test phases help identify issues before a public release. 
•  They are both part of User Acceptance Testing (UAT). 
 
What is A/B Testing and why is it needed? 
•  A/B Testing compares two versions of a web page or application to determine which one 
performs better.  
•  It's used to make data-driven decisions for optimizing user experience, increasing 
conversions, and improving product features. 
 
What is Monkey (Ad Hoc) Testing and what are the benefits it 
provides? 
•  Monkey (Ad Hoc) Testing is informal, exploratory testing without predefined test cases.  
•  Testers interact with the software randomly to discover issues that might not be covered 
by formal testing.  
•  It helps uncover unexpected defects and assess the software's robustness. 
 
  25 
What is Security Testing and what are the benefits it provides? 
•  It is a type of testing performed by a special team. Any hacking method can penetrate 
the system. 
•  Security Testing is done to check how the software, application, or website is secure 
from internal and/or external threats.  
•  This testing includes how much software is secure from malicious programs, viruses and 
how secure & strong the authorization and authentication processes are. 
•  It also checks how software behaves for any hacker’s attack & malicious programs and 
how software is maintained for data security after such a hacker attack.

JavaScript Mock-2 Questions and Answers 
How does JavaScript differ from compiled languages, and what unique 
features characterize JavaScript as an interpreted language? 
•  JavaScript is an interpreted language, which means it's executed line-by-line, like 
reading a script.  
•  Compiled languages are first translated into machine code before execution. 
•  This gives JavaScript the advantage of being more flexible and easier to use. 
 
Can you explain what NodeJS is and why it's important for JavaScript? 
•  NodeJS is a runtime environment for JavaScript that allows it to run on servers and 
outside of web browsers.  
•  It's crucial for server-side scripting, building APIs, and creating scalable network 
applications. 
 
What are the differences between 'var', 'let', and 'const'? 
•  They are all used for variable declaration. 
•  var keyword is used in all JavaScript code from 1995 to 2015. 
•  let and const keywords were added to JavaScript in 2015. 
•  var is function-scoped, which means it doesn't respect block scope.  
•  var is hoisted while let and const cannot be hoisted. 
•  let and const are block-scoped and allow better control over variable scope.  
•  let variables can be reassigned, while const variables are constant once assigned.  
•  const is especially useful for declaring values that shouldn't change during execution. 
 
List and briefly describe the basic data types in JavaScript. 
•  There are 7 primitives: String, Number, Bigint, Boolean, Undefined, Null, Symbol 
•  There are also Reference-Object data types: arrays, objects, collections, etc. 
•  String: A String is a sequence of characters like "John Doe".Strings are written with 
quotes. You can use single or double quotes but mostly double quotes. 
•  Numbers: All JS numbers are stored as decimal numbers (floating point).Numbers can 
be written with, or without decimals. 
•  BigInt: All JS numbers are stored in a a 64-bit floating-point format. JavaScript BigInt is 
a new datatype (2020) that can be used to store integer values that are too big to be 
represented by a normal JavaScript Number. 
•  Boolean: Boolean can only have two values: true or false. It is used often with 
conditional statements. 
•  Undefined: In JS, a variable without a value, has the value undefined. The type is also 
undefined. 
 www.techglobalschool.com 
 
  4 
•  Array: JS arrays are used to store multiple data and written with square brackets []. 
Array items are separated by commas. Array indexes are zero-based. 
•  Object: JS objects are used to store complex data with key-value pairs and written with 
curly braces {}. Object properties are written as name:value pairs, separated by 
commas. 
What is the difference between 'null' and 'undefined' in JavaScript? 
•  null represents an intentional absence of any object value, while undefined indicates 
that a variable has been declared but hasn't been assigned a value. 
•  Type of null is object while type of undefined is undefined. 
•  null is converted to zero while performing primitive operations while undefined is 
converted to NaN. 
 
What are the differences between '=' and '==' and '==='? 
•  = is the assignment operator, used to assign a value to a variable. 
•  == is the equality operator, which compares values for equality with type coercion.  
•  === is the strict equality operator, which compares values for equality without type 
coercion.  
NOTE: type coercion is the process of converting a value from one data type to 
another, usually during runtime, to facilitate an operation or comparison. JavaScript 
performs type coercion in various situations, particularly when using operators like == 
(equality) and + (addition). 
•  Using === is recommended for accurate comparisons, as it considers both value and 
type. 
 
What are the 'template literals' in JavaScript? 
•  Template literals or template strings are string literals allowing embedded expressions.  
•  These are enclosed by the back-tick (`) character instead of double or single quotes.  
•  In ES6, this feature enables using dynamic expressions and offer improved readability 
and flexibility when constructing complex strings. 
 
What is array in JavaScript and why do we need it? 
•  An array in JavaScript is a special data structure that allows you to store and organize 
multiple values (elements) in a single variable.  
•  It's like having a collection of items in a list.  
•  Arrays are essential because they provide a way to work with groups of related data 
efficiently.  
•  You can access, manipulate, and iterate through array elements, making it easier to 
perform tasks like storing a list of names, numbers, or any other data. 
•  The typeof operator in JavaScript returns "object" for arrays. 
 www.techglobalschool.com 
 
  5 
What are the differences between array slice and splice methods? 
•  array.slice(start, end): This method creates a new array by extracting a portion of the 
original array from the start index (inclusive) to the end index (exclusive). The original 
array remains unchanged. 
•  array.splice(start, deleteCount, item1, item2, ...): The splice method changes the 
original array. It removes elements starting from the start index, as specified by 
deleteCount. You can also add new elements at that position if you provide item1, item2, 
and so on. It returns an array containing the removed elements. 
 
What are the differences between array map, filter and reduce methods? 
•  The map() method creates a new array by applying a provided function to each element 
of the original array. 
•  It returns a new array of the same length as the original array, with each element 
transformed by the provided function. 
 
const numbers = [1, 2, 3]; 
const doubled = numbers.map(x => x * 2); // [2, 4, 6] 
 
 
•  The filter() method creates a new array containing elements that meet a specified 
condition. 
•  It returns a new array with elements for which the provided function returns true 
 
const numbers = [1, 2, 3, 4, 5]; 
const evens = numbers.filter(x => x % 2 === 0); // [2, 4] 
 
 
•  The reduce() method applies a provided function to accumulate values of an array, 
resulting in a single value. 
•  It returns a single accumulated value, such as a sum, product, or any other reduced 
result. 
 
const numbers = [1, 2, 3, 4]; 
const sum = numbers.reduce((acc, curr) => acc + curr, 0); // 
10 
 
 
•  map() and filter() both return new arrays based on the original array, while reduce() 
returns a single accumulated value. 
•  map() transforms each element based on the provided function, filter() selects elements 
that meet a condition, and reduce() accumulates values. 
 
 www.techglobalschool.com 
 
  6 
What are the differences between array some and every methods? 
•  The some() method checks if at least one element in the array satisfies a specified 
condition. 
•  It returns true if at least one element satisfies the condition; otherwise, it returns false. 
 
const numbers = [1, 2, 3, 4, 5]; 
const hasEvenNumber = numbers.some(x => x % 2 === 0); // true 
 
 
•  The every() method checks if all elements in the array satisfy a specified condition. 
•  It returns true if all elements satisfy the condition; otherwise, it returns false. 
 
const numbers = [2, 4, 6, 8]; 
const allEvenNumbers = numbers.every(x => x % 2 === 0); // 
true 
 
How do you sort elements in an array in JavaScript? 
•  You can sort elements in an array using the array.sort() method.  
•  By default, it sorts elements as strings, which may not give the expected result for 
numbers.  
•  To sort numbers correctly, you can provide a comparison function as an argument. For 
example: 
const numbers = [5, 1, 3, 2, 4]; 
numbers.sort((a, b) => a - b); // This sorts the array in 
ascending order 
 
What are loops in JavaScript? 
•  Loops in JavaScript are control structures that allow you to execute a block of code 
repeatedly.  
•  They are essential for automating repetitive tasks or iterating through arrays, objects, or 
other data structures.  
•  JavaScript offers several types of loops: 
o  for loop: Executes a block of code a specified number of times. 
o  while loop: Repeats a block of code as long as a condition is true. 
o  do...while loop: Similar to a while loop, but it always runs the block of code at 
least once. 
o  for...in loop: Iterates over the properties of an object. 
o  for...of loop: Iterates over the values of an iterable object, like an array. 
•  break;  is used to terminate the loop. 
•  continue; is used to skip only current iteration if a specified condition occurs and 
  continues with the next iteration in the loop. 
 www.techglobalschool.com 
 
  7 
What are function expressions? 
•  Function expressions are a way to define functions in JavaScript by assigning them to 
variables or using them within expressions.  
•  Unlike function declarations, which are hoisted to the top of their containing scope and 
can be called before they appear in the code, function expressions are not hoisted.  
•  This means that you can only call a function expression after it has been defined. 
•  Function expressions can also be used as arguments to other functions, stored in arrays 
or objects, and passed around like any other value in JavaScript.  
•  They are particularly useful when you need to create functions dynamically or pass them 
as callbacks to other functions. 
 
const greet = function(name) { 
  return `Hello, ${name}!`; 
}; 
console.log(greet("John")); // "Hello, John!" 
 
 
What is lambda or arrow functions in JavaScript? 
•  Lambda functions, also known as arrow functions, are a concise way to define functions 
in JavaScript.  
•  They provide a shorter syntax compared to traditional function expressions.  
•  Arrow functions are particularly useful for defining anonymous functions and for 
functions with simple, single-line bodies. 
•  We don't need the function keyword, the return keyword, and the curly brackets. 
•  Using const is safer and preferred, because a function expression is always constant 
value. 
•  We can only omit the return keyword and the curly brackets if the function body has a 
single statement. 
•  We can skip the parentheses if we have only one parameter. 
 
// Traditional function expression 
const add = function(x, y) { 
  return x + y; 
}; 
 
// Arrow function 
const add = (x, y) => x + y; 
 
 
 
 
 www.techglobalschool.com 
 
  8 
What is callback function and why do we need it?  
•  A callback function is a function that is passed as an argument to another function and 
is executed inside that function.  
•  Callbacks are commonly used in JavaScript. 
•  Callbacks are essential because they allow you to write code that doesn't block the 
execution of other code.  
•  This is crucial for creating responsive and non-blocking applications, especially in web 
development.  
•  Callbacks enable you to define what should happen after a certain operation completes. 
 
What is callback hell? 
•  Callback hell, also known as the "Pyramid of Doom," refers to a situation where multiple 
nested callback functions make the code structure complex and hard to read.  
•  It occurs when you have a series of asynchronous operations that depend on each 
other, leading to deeply nested callback functions. 
•  Callback hell can make code difficult to maintain and debug.  
•  To address this issue, developers often use techniques like promises, async/await, or 
modularization to improve code readability and structure. 
 
asyncFunction1(() => { 
  asyncFunction2(() => { 
    asyncFunction3(() => { 
      // ... and so on 
    }); 
  }); 
}); 
 
What are enhanced object literals in JavaScript? 
Enhanced object literals are a set of enhancements introduced in ECMAScript 2015 (ES6) that 
make it easier and more concise to define objects in JavaScript. 
 
//ES6 
let x = 10, y = 20; 
obj = { x, y }; 
console.log(obj); // {x: 10, y:20} 
 
//ES5 
var x = 10, y = 20; 
obj = { x: x, y: y }; 
console.log(obj); // {x: 10, y:20} 
 
 
 www.techglobalschool.com 
 
  9 
What is the currying function in JavaScript? 
•  Currying is a functional programming technique where a function that takes multiple 
arguments is transformed into a series of functions, each taking one argument.  
•  It allows you to partially apply a function by providing one argument at a time. 
•  Currying is useful for creating reusable functions and for building more specialized 
functions from general ones.  
•  It's a powerful technique in functional programming. 
 
function add(x) { 
  return function(y) { 
    return x + y; 
  }; 
} 
 
const add5 = add(5); 
const result = add5(3); // Result is 8 
 
What are the spread operator and rest parameter and differences between 
them? 
•  Spread Operator (...): The spread operator allows you to expand an iterable (e.g., an 
array) into individual elements.  
•  You can use it in various contexts, such as when creating a new array, passing function 
arguments, or merging objects. 
const arr = [1, 2, 3]; 
const newArr = [...arr, 4, 5]; // Creates a new array [1, 2, 
3, 4, 5] 
 
 
•  Rest Parameter (...paramName): The rest parameter is used in function declarations to 
collect multiple arguments into a single array.  
•  It allows you to handle an arbitrary number of arguments conveniently. 
function sum(...numbers) { 
  return numbers.reduce((total, num) => total + num, 0); 
} 
 
 
•  The spread operator is used to split elements (e.g., from an array), while the rest 
parameter is used to collect elements into an array (e.g., function arguments). 
•  The spread operator is typically used in array or object literals, whereas the rest 
parameter is used in function parameters. 
 
 
 www.techglobalschool.com 
 
  10 
What is the difference between Shallow and Deep copy? 
•  Shallow Copy: A shallow copy of an object or array creates a new instance of the top-
level object or array, but it doesn't duplicate nested objects or arrays. Instead, it 
references them. Modifying nested objects will affect both the original and the copied 
object. 
•  Deep Copy: A deep copy, on the other hand, creates a completely independent 
duplicate of the original object or array, including all nested objects or arrays. Changes 
made to the copy won't affect the original. 
 
What is nullish coalescing operator (??)? 
•  The nullish coalescing operator (??) is used to provide a default value when a 
variable is null or undefined.  
•  It's helpful for handling cases where you want to assign a default value only when the 
variable is explicitly null or undefined, but not for other falsy values like 0, false, or an 
empty string. 
•  The key difference from the logical OR (||) operator is that ?? only falls back to the 
default value when the variable is null or undefined, not for other falsy values. 
•  The nullish coalescing operator is particularly useful when dealing with optional 
properties in objects or when setting default values for function parameters. 
 
console.log(null ?? true); // true  
console.log(false ?? true); // false  
console.log(undefined ?? true); // true 
What is this keyword and why do we use it in JavaScript? 
•  this keyword in JavaScript refers to the current object or context in which the code is 
executing.  
•  It allows us to access and manipulate the properties and methods of the object that the 
function is a part of.  
•  this is a fundamental concept in JavaScript because it helps us work with different 
objects and their data without hardcoding specific values. 
 
// Using this in a object method 
const instructor = { 
    fName: 'John', 
    lName: 'Doe', 
    field: 'Science', 
    fullName() { 
        return `${this.fName} ${this.lName}`; 
    } 
}; 
 
console.log(instructor.fullName()); // John Doe 
 www.techglobalschool.com 
 
  11 
What is super keyword and why do we use it in JavaScript? 
•  super keyword is used in JavaScript within classes to call methods and access 
properties of a parent class (or superclass).  
•  It's typically used when creating a subclass (a class that inherits from another class) to 
invoke the constructor and methods of the parent class.  
•  It helps in reusing and extending the behavior of the parent class in the child class. 
 
What is immutable in JavaScript? Explain in detail. 
•  Immutability in JavaScript refers to the concept of making data or objects unchangeable 
after they are created.  
•  Immutable data cannot be modified, which can lead to more predictable and reliable 
code. Instead of changing the original data, you create new instances with the desired 
modifications.  
•  This is often used with data structures like arrays and objects to prevent unintended side 
effects. 
 
What is scope in JavaScript? Explain in detail. 
•  Scope determines the accessibility (visibility) of variables, objects, and functions. 
•  JavaScript has 4 types of scope: 
 
1. Function Scope - (Local Scope) 
•  Variables declared within a JavaScript function, become LOCAL to the function. 
•  They can't be used outside the function. 
•  Variables declared with var, let and const are similar when declared inside a function 
considering the scope. 
 
2. Block Scope 
•  JavaScript had only Global Scope and Function Scope before ES6 (2015). 
•  Variables declared with the var keyword can NOT have block scope. 
•  ES6 introduced two important new JavaScript keywords: let and const. 
•  These two keywords provide Block Scope in JavaScript. 
•  Variables declared inside a { } block with let or const cannot be accessed from outside 
the block. 
 
3. Global Scope 
•  Variables declared globally (outside any function) have Global Scope. 
•  Global variables can be accessed from anywhere in the program. 
•  Variables declared with var, let and const are quite similar when declared outside a 
block. 
 
 
 
 www.techglobalschool.com 
 
  12 
4. Lexical Scope 
•  Used in case of nested functions and defines the accessibility of variables for inner and 
outer functions. 
•  In simple terms, lexical scope means that a variable or function can only be accessed 
within the scope in which it is defined.  
•  The scope of a variable or function is determined by its position in the source code. 
•  NOTE: Before ES6 (2015), JavaScript had only Global Scope and Function Scope. 
 
 
What is JSON why we need it and what are its common operations? 
•  JSON stands for JavaScript Object Notation and is a lightweight data-interchange 
format.  
•  It is primarily used for data exchange between a server and a web application, but it has 
become a universal data format that can be used in various programming languages.  
•  JSON is text-based and easy for humans to read and write, and machines can parse it 
and generate it. 
 
Why do we need JSON? 
•  Data Interchange: JSON is used for transmitting data between a server and a web 
application. It provides a standardized format for data exchange, making it easier for 
different systems to communicate. 
•  Human-Readable: JSON is easy to read, write, and understand, which is useful for 
developers when debugging or inspecting data. 
 
Common JSON Operations: 
•  Serialization: Converting a data structure (e.g., an object or an array) into a JSON string 
is known as serialization. This is done using the JSON.stringify() method. 
const data = { name: "John", age: 30 }; 
const jsonData = JSON.stringify(data); 
•  Deserialization: The reverse process, where a JSON string is converted back into a 
data structure, is called deserialization. This is accomplished using the JSON.parse() 
method. 
const jsonString = '{"name":"John","age":30}'; 
const data = JSON.parse(jsonString); 
 
 
•  Accessing Data: Once data is in JSON format, you can access specific values using 
dot notation or bracket notation, just like you would with JavaScript objects. 
•  Modifying Data: You can also modify JSON data by updating its values, adding, or 
removing properties, and nesting objects or arrays. 
 
 
 
 
 www.techglobalschool.com 
 
  13 
What is serialization and deserialization? 
•  Serialization: Converting a data structure (e.g., an object or an array) into a JSON string 
is known as serialization. This is done using the JSON.stringify() method. 
const data = { name: "John", age: 30 }; 
const jsonData = JSON.stringify(data); 
•  Deserialization: The reverse process, where a JSON string is converted back into a 
data structure, is called deserialization. This is accomplished using the JSON.parse() 
method. 
 
const jsonString = '{"name":"John","age":30}'; 
const data = JSON.parse(jsonString); 
 
What is hoisting in JavaScript? 
•  Hoisting in JavaScript is a behavior where variable and function declarations are moved 
to the top of their containing scope during the compilation phase, before the code is 
executed.  
•  It may seem like variables are declared where you write them, but in reality, they are 
processed before the code runs. 
•  However, it's important to note that only the declarations are hoisted, not the 
initializations. So, while the variable declaration is moved to the top, the value 
assignment remains in place. 
 
console.log(x); // undefined 
var x = 5; 
// "x" is hoisted, and the code is interpreted as below: 
var x; 
console.log(x); // undefined 
x = 5; 
 
What is IIFE(Immediately Invoked Function Expression)? 
•  IIFE stands for Immediately Invoked Function Expression. 
•  It is a common JavaScript design pattern used to create a function expression and 
execute it immediately after its declaration.  
•  IIFE is typically wrapped in parentheses to distinguish it as an expression and to prevent 
its variables from polluting the global scope. 
 
(function() { 
    console.log('Hello World'); // Hello World 
})(); 
 
 www.techglobalschool.com 
 
  14 
What are closures in JavaScript? 
•  A closure is a function that has access to its own scope, the outer (enclosing) function's 
scope, and the global scope.  
•  This allows the inner function to access variables from its containing functions even after 
they have completed execution. 
•  Closures are commonly used for data encapsulation, creating private variables, and 
implementing callback functions. 
 
function outerFunction() { 
  let outerVar = "I'm from outer function"; 
 
  function innerFunction() { 
    console.log(outerVar); 
  } 
 
  return innerFunction; 
} 
 
const myClosure = outerFunction(); 
myClosure(); // I'm from outer function 
What are bind, call and apply methods? Why do we use them? 
•  bind(): is used to create a new function that, when invoked, has its this value set to a 
specific object, and it allows you to pre-specify arguments.  
•  This is often used to bind a function to a particular context. 
 
const greet = function(name) { 
  console.log(`Hello, ${name}!`); 
}; 
 
const greetJohn = greet.bind(null, "John"); 
greetJohn(); // Hello, John! 
 
•  call(): is used to invoke a function with a specific this value and arguments passed 
individually. 
 
const person = { 
  name: "Alice" 
}; 
 
function introduce(age) { 
  console.log(`I'm ${this.name} and I'm ${age} years old.`); 
} 
introduce.call(person, 25); // I'm Alice and I'm 25 years old. 
 www.techglobalschool.com 
 
  15 
•  apply(): Similar to call(), the apply() method is used to invoke a function with a specific 
this value and arguments passed as an array. 
 
const numbers = [1, 2, 3, 4, 5]; 
 
function sum() { 
  return numbers.reduce((total, num) => total + num, 0); 
} 
 
const result = sum.apply(null, numbers); 
console.log(result); // 15 
 
What is AJAX? 
•  AJAX stands for Asynchronous JavaScript and XML, and is a set of web 
development techniques used to create asynchronous web applications.  
•  It allows web pages to send and receive data from a server without the need to refresh 
the entire page.  
•  While the acronym mentions XML, in practice, data formats like JSON are often used 
instead.  
•  AJAX is a key technology for building dynamic and interactive web applications. 
 
What are the different ways to deal with Asynchronous Code? 
•  Asynchronous JavaScript refers to the ability of JavaScript to execute code that 
doesn't block the main thread of execution.  
•  This allows for non-blocking operations like network requests, file reading/writing, timers, 
and user interactions, where the program doesn't have to wait for one operation to 
complete before moving on to the next one.  
•  Asynchronous operations are crucial for building responsive and efficient web 
applications. 
•  To handle asynchronous JavaScript, we use one or more of the following techniques; 
 
1. Callbacks:  
•  Callbacks are functions that you pass as arguments to another function and are 
executed once the asynchronous operation is complete.  
•  Callbacks have been a traditional way to handle asynchronous code in JavaScript. 
 
2.Promise: 
•  Promises are a more modern and structured way to handle asynchronous code.  
•  They represent a value that might be available now, in the future, or never.  
•  Promises provide methods like .then() to attach success and error handlers to execute 
when the asynchronous operation completes or fails. 
 
 www.techglobalschool.com 
 
  16 
3. Async/Await:  
•  Async functions provide a way to write asynchronous code that looks more like 
synchronous code, making it easier to read and reason about.  
•  We can use the async keyword before a function declaration and await inside that 
function to pause execution until a promise is resolved. 
 
4. Event Handlers:  
•  Event-driven programming is common in web development.  
•  We can attach event handlers to elements and respond to events like clicks, inputs, or 
HTTP requests. 
•  NOTE: Promises and async/await have become the preferred ways to handle 
asynchronous code due to their readability and maintainability, especially in complex 
applications.  
•  Additionally, many modern web APIs and libraries are designed around promises and 
async/await, making them a natural choice for working with asynchronous JavaScript. 
 
What is promise, why wee ned it and what are the states of promise? 
•  A promise in JavaScript is an object representing the eventual completion (or failure) of 
an asynchronous operation and its resulting value.  
•  Promises are used to handle asynchronous operations in a more structured and 
readable way, making it easier to manage complex workflows. 
Promises have three states: 
•  Pending: Initial state when the promise is neither fulfilled nor rejected. 
•  Fulfilled (Resolved): The state when the asynchronous operation is successful, and the 
promise is assigned a value. 
•  Rejected: The state when the asynchronous operation encounters an error or fails, and 
the promise is given a reason for failure. 
 
 
What is an async function in JavaScript? 
•  An async function in JavaScript is a special type of function that allows you to write 
asynchronous code in a more synchronous and readable manner.  
•  It makes working with promises more intuitive and simplifies error handling using 
try/catch.  
•  Inside an async function, we can use the await keyword to pause the function's 
execution until a promise is resolved, making it look like the code is executing in a 
synchronous manner. 
 
 
 
 
 
 www.techglobalschool.com 
 
  17 
What is call stack in JavaScript? 
•  It is a mechanism for the JS interpreter to keep track of its place in a script that calls 
multiple functions. 
•  It is simply keeping the track of what function is currently being run and what functions 
are called from within that function. 
•  It works based on LIFO (last-in-first-out) principle. 
 
What is an event loop in JavaScript? 
•  The event loop in JavaScript is a crucial part of handling asynchronous code execution.  
•  It's responsible for managing the execution of callbacks and events, such as those 
associated with timers, user interactions, and I/O operations.  
•  The event loop ensures that code execution remains non-blocking, allowing the program 
to remain responsive. 
•  The event loop continually checks the call stack for functions to execute and the 
message queue for pending events or callbacks to process.  
•  It moves items from the queue to the stack when the stack is empty, ensuring that 
asynchronous tasks are executed in the order they were received. 
 
What are modules and why do we need them? 
•  Modules in JavaScript are a way to encapsulate code into separate, reusable, and 
maintainable files.  
•  They help organize code by breaking it into smaller, focused units, each with its own 
scope.  
•  Modules improve code maintainability, reusability, and reduce the risk of naming 
conflicts in large applications. 
•  Modules are crucial for structuring complex applications, allowing developers to work on 
specific parts of a project independently, and facilitating code sharing and collaboration. 
 
Module Systems in JavaScript: 
•  CommonJS: CommonJS is a module system used in server-side JavaScript (e.g., 
Node.js). It uses require to import modules and module.exports to export them. 
 
// ModuleA.js 
module.exports = { message: "Hello from Module A" }; 
 
// main.js 
const moduleA = require('./ModuleA'); 
console.log(moduleA.message); 
 
 
•  ES6 Modules: ES6 introduced the import and export syntax for working with modules 
in JavaScript. 
 www.techglobalschool.com 
 
  18 
Export:  
•  To make parts of a module accessible outside of the module, we use the export 
keyword.  
•  We can export variables, functions, or classes. 
Import:  
•  To use the exported code from a module in another module, we use the import 
statement. 
 
// ModuleA.js 
export const message = "Hello from Module A"; 
 
// main.js 
import { message } from './ModuleA.js'; 
console.log(message); 
 
How does prototypal inheritance work in JavaScript? 
•  In JavaScript, objects can inherit properties and methods from other objects through a 
mechanism called prototypal inheritance. 
•  Each object has an internal reference to another object called its prototype.  
•  When you access a property or method on an object, JavaScript first looks for it on the 
object itself. If it doesn't find it, it searches up the prototype chain until it finds the 
property or reaches the end of the chain. 
 
function Animal(name) { 
  this.name = name; 
} 
 
Animal.prototype.sayHello = function() { 
  console.log(`Hello, I'm ${this.name}`); 
}; 
 
const dog = new Animal("Fluffy"); 
dog.sayHello(); // Output: "Hello, I'm Fluffy" 
 
What is a prototype chain in JavaScript? 
•  The prototype chain is the series of objects linked through their prototypes. When you 
access a property or method on an object, JavaScript traverses this chain to find the 
property or method. 
•  An object's prototype is the object it inherits from, and that inherited object can have its 
own prototype, forming a chain of objects. The chain continues until the end of the chain 
is reached (typically the Object.prototype, which is the root of the chain). 
 
 www.techglobalschool.com 
 
  19 
What is a constructor, why do need it and how do we use it? 
•  What is a Constructor: A constructor function is a regular function used to create and 
initialize objects in JavaScript. It's called with the new keyword to create instances of 
objects. 
•  Why We Need It: Constructors allow you to create multiple objects with the same 
structure and behavior. They help encapsulate object creation and property assignment 
logic. 
•  How to Use It: 
 
function Person(name, age) { 
  this.name = name; 
  this.age = age; 
} 
 
const john = new Person("John", 30); 
 
What are classes in ES6, how do you extend and why do we need it? 
•  JS Classes: In ES6 (ECMAScript 2015), JavaScript introduced a more structured way to 
define constructor functions using the class keyword.  
•  Classes provide syntactical sugar over constructor functions, making object-oriented 
programming in JavaScript more readable and familiar to developers from other 
languages. 
•  Extending Classes: You can extend a class using the extends keyword to create a 
subclass.  
•  Subclasses inherit properties and methods from their parent class. 
•  Why We Need Classes: Classes provide a more structured and organized way to define 
and work with objects, making code more modular and easier to understand, especially 
for larger applications. 
 
class Animal { 
  constructor(name) { 
    this.name = name; 
  } 
} 
 
class Dog extends Animal { 
  bark() { 
    console.log(`${this.name} says woof!`); 
  } 
} 
 
 
 
 www.techglobalschool.com 
 
  20 
What are static properties and methods in JavaScript? 
•  Static Properties are properties that belong to a class itself rather than to instances of 
the class.  
•  They are accessed using the class name, not an instance of the class. 
•  Static Methods are methods that are called on the class itself, not on instances.  
•  They are often used for utility functions that don't require access to instance-specific 
data. 
 
class MathUtils { 
  static add(x, y) { 
    return x + y; 
  } 
} 
 
const sum = MathUtils.add(5, 3); // Static method usage 
 
Double or Triple the Word 
Write a function named as doubleOrTripleWord() which takes a string word as an argument 
and returns the given word back tripled if the string length is even or doubled if the string length 
is odd when invoked. 
 
Examples: 
doubleOrTripleWord("Tech")     -> "TechTechTech" 
doubleOrTripleWord("Apple")     -> "AppleApple” 
doubleOrTripleWord("")       -> "" 
doubleOrTripleWord(" ")       -> " " 
doubleOrTripleWord("1")       -> "11" 
doubleOrTripleWord("22")       -> "222222" 
 
First and Last Word 
Write a function named as firstlastWord() which takes a string word as an argument and 
returns the first and last words from the given string when invoked. 
NOTE: Return empty string if the given string does not have any word. 
 
Examples: 
firstLastWord("Hello World")     -> "HelloWorld" 
firstLastWord("I like JavaScript")    -> "IJavaScript” 
firstLastWord("Hello")       -> "HelloHello" 
firstLastWord("")         -> "" 
firstLastWord("  ")       -> "" 
 
 www.techglobalschool.com 
 
  21 
Has Vowel 
Write a function named hasVowel() which takes a string argument and returns true if the 
string has a vowel, returns false if the string doesn’t contain any vowel letter. 
NOTE: Vowels are = a, e, o, u, i. 
NOTE: Ignore upper/lower cases. 
 
Examples: 
hasVowel("")        -> false 
hasVowel("Javascript")     -> true 
hasVowel("Tech Global")     -> true 
hasVowel("1234")       -> false 
hasVowel("ABC")       -> true 
 
 
Start Vowel 
Write a function named as startVowel() which takes a string word as an argument and returns 
true if given string starts with a vowel, and false otherwise when invoked. 
NOTE: Vowel letters: a, e, i o, u, A, E, I, O, U 
 
Examples: 
startVowel("Hello")     -> false 
startVowel("Apple")    -> true 
startVowel("orange")   -> true 
startVowel("")     -> false 
startVowel("  ")     -> false 
startVowel("123")     -> false 
 
Average of Edges 
Write a function named averageOfEdges() which takes three number arguments and will 
return average of min and max numbers. 
 
Examples: 
averageOfEdges(0, 0, 0)   -> 0 
averageOfEdges(0, 0, 6)   -> 3 
averageOfEdges(-2, -2, 10)   -> 4 
averageOfEdges(-3, 15, -3)   -> 6 
averageOfEdges(10, 13, 20)   -> 15 
 
 
 
 
 
 www.techglobalschool.com 
 
  22 
Swap First and Last Characters 
Write a function named replaceFirstLast() which takes a string argument and returns a new 
string with the first and last characters replaced. 
NOTE: If the length is less than 2, return an empty string. 
NOTE: Ignore extra spaces before and after the string. 
 
Examples: 
replaceFirstLast("")         ->  "" 
replaceFirstLast("Hello")       ->  "oellH" 
replaceFirstLast("Tech Global")     -> "lech GlobaT" 
replaceFirstLast("A")       -> "" 
replaceFirstLast("    A      ")      -> "" 
 
Swap First and Last Four Characters 
Write a function named as swap4() which takes a string word as an argument and returns the 
string back with its first and last 4 characters swapped when invoked. 
NOTE: Return empty string if the given string does not have 8 or more characters. 
 
Examples: 
swap4("abc")       -> "" 
swap4("JavaScript")      -> "riptScJava" 
swap4("TechGlobal")     -> "obalGlTech" 
swap4("")         -> "" 
swap4("  ")       -> "" 
swap4("Apple")       -> "" 
 
Swap First and Last Words 
Write a function named as swapFirstLastWord() which takes a string word as an argument 
and returns the string back with its first and last words swapped when invoked. 
NOTE: Return empty string if the given string does not have 2 or more words. 
 
Examples: 
swapFirstLastWord("Hello World")      -> "World Hello" 
swapFirstLastWord("I like JavaScript")   -> "JavaScript like I" 
swapFirstLastWord("foo bar foo bar")     -> "bar bar foo foo" 
swapFirstLastWord("")         -> "" 
swapFirstLastWord("  ")         -> "" 
swapFirstLastWord("Hello")        -> "" 
swapFirstLastWord("Hello   ")       -> "" 
 
 www.techglobalschool.com 
 
  23 
Count Positive Numbers 
Write a function named countPos() which takes an array of numbers as an argument and 
returns how many elements are positive when invoked.  
 
Examples: 
countPos([-45, 0, 0, 34, 5, 67])     -> 3 
countPos([-23, -4, 0, 2, 5, 90, 123])   -> 4 
countPos([0, -1, -2, -3])       -> 0 
 
Find Even Numbers 
Write a function named as getEvens() which takes 2 number arguments and returns all the 
even numbers as an array stored from smallest even number to greatest even number when 
invoked. 
NOTE: Make your code dynamic that works for any numbers and return empty array if there are 
no even numbers in the range of given 2 numbers. 
Assume you will not be given negative numbers. 
 
Examples: 
getEvens(2, 7)    -> [ 2, 4, 6 ] 
getEvens(17, 5)    -> [ 6, 8, 10, 12, 14, 16 ] 
getEvens(4, 4)    -> [ 4 ] 
getEvens(3, 3)    -> [ ] 
 
Find Numbers Divisible By 5 
Write a function named as getMultipleOf5() which takes 2 number arguments and returns all the 
numbers divisible by 5 as an array stored from first found match to last found match when 
invoked. 
NOTE: Make your code dynamic that works for any numbers and return empty array if there are 
no numbers divisible by 5 in the range of given 2 numbers. 
Assume you will not be given negative numbers. 
Examples: 
getMultipleOf5(3, 17)    -> [ 5, 10, 15] 
getMultipleOf5(23, 5)    -> [ 20, 15, 10, 5 ] 
getMultipleOf5(5, 5)      -> [ 5 ] 
getMultipleOf5(2, 4)      -> [ ] 
 
 
 www.techglobalschool.com 
 
  24 
Count Negative Numbers 
Write a function named countNeg() which takes an array of numbers as an argument and 
returns how many elements are negative when invoked.  
 
Examples: 
countNeg([-45, 0, 0, 34, 5, 67])     -> 1 
countNeg([-23, -4, 0, 2, 5, 90, 123])   -> 2 
countNeg([0, -1, -2, -3])       -> 3 
Count A 
Write a function named countA() which takes a string argument and returns how many A or a 
there are in the given string when invoked. 
NOTE: Ignore case sensitivity.  
 
Examples: 
countA("TechGlobal is a QA bootcamp")       -> 4 
countA("QA stands for Quality Assurance")     -> 5 
countA("Cypress")             -> 0 
 
Count Words 
Write a function named countWords() which takes a string argument and returns the total 
count of words in the given string when invoked. 
NOTE: Be careful about the extra whitespaces before and after the string. 
 
Examples: 
countWords("     Javascript is fun       ")         -> 3 
countWords("Cypress is an UI automation tool.    ")     -> 6  
countWords("1 2 3 4")             -> 4 
 
Factorial 
Write a function named as factorial() which takes a number as an argument and returns the 
factorial of the number when invoked. 
NOTE: Mathematically, the factorial of a non-negative integer n is defined as: 
n! = n × (n-1) × (n-2) × ... × 2 × 1 
Assume you will not be given a negative number. 
 
Examples: 
factorial(5)     -> 120 
factorial(4)    -> 24 
factorial(0)    -> 1 
factorial(1)    -> 1 
 www.techglobalschool.com 
 
  25 
Count 3 or Less 
Write a function named as count3OrLess() which takes a string word as an argument and 
returns the count of the words that has 3 characters or less when invoked. 
 
Examples: 
count3OrLess("Hello")         -> 0 
count3OrLess("Hi John")         -> 1 
count3OrLess("JavaScript is fun")       -> 2 
count3OrLess("My name is John Doe")     -> 3 
count3OrLess("")           -> 0 
 
 
Remove Extra Spaces 
Write a function named as removeExtraSpaces() which takes a string word as an argument 
and returns the string back with all extra spaces removed when invoked. 
 
Examples: 
removeExtraSpaces("Hello")           -> "Hello" 
removeExtraSpaces("    Hello    World  ")       -> "Hello World" 
removeExtraSpaces("   JavaScript is        fun")    -> "JavaScript is fun” 
removeExtraSpaces("")             -> ""  
 
 
Middle Number 
Write a function named middleInt() which takes three number arguments and return the middle 
number.  
 
Examples: 
middleInt(1, 2, 2)     -> 2 
middleInt(5, 5, 8)     -> 5 
middleInt(5, 3, 5)     -> 5 
middleInt(1, 1, 1)     -> 1 
middleInt(-1, 25, 10)   -> 10 
 
 
 
 
 
 
 www.techglobalschool.com 
 
  26 
First Duplicate Element 
Write a function named as firstDuplicate() which takes an array argument and returns the first 
duplicated number in the array when invoked. 
NOTE: Make your code dynamic that works for any array and return -1 if there are no duplicates 
in the array. For two elements to be considered as duplicated, value and data types of the 
elements must be same. 
 
Examples: 
firstDuplicate([ 3, 7, 10, 0, 3, 10 ])      -> 3 
firstDuplicate([ 5, 7, 7, 0, 5, 10 ])      -> 5 
firstDuplicate([ 5, '5', 3, 7, 4 ])      -> -1 
firstDuplicate([ 123, 'abc', '123', 3, 'abc' ])    -> 'abc' 
firstDuplicate([ 1, 2, 3])        -> -1 
firstDuplicate([ 'foo', 'abc', '123', 'bar’ ])     -> -1 
 
 
Find All Duplicate Elements 
Write a function named as getDuplicates() which takes an array argument and returns all the 
duplicated elements in the array when invoked. 
NOTE: Make your code dynamic that works for any array and return empty array if there are no 
duplicates in the array. For two elements to be considered as duplicated, value and data types 
of the elements must be same. 
 
Examples: 
getDuplicates([ 0, -4, -7, 0, 5, 10, 45, -7, 0 ])      -> [ 0, -7 ] 
getDuplicates([ 1, 2, 5, 0, 7 ])          -> [ ] 
getDuplicates(['A', 'foo', '12’ , 12, 'bar', 'a', 'a', 'foo' ])    -> [ 'foo', 'a’ ] 
getDuplicates([ 'foo', '12' , 12, 'bar', 'a' ])       -> [ ] 
 
 
Count Vowels 
Write a function named as countVowels() which takes a string word as an argument and 
returns the count of the vowel letters when invoked. 
NOTE: Vowel letters are A,E, O, U, I, a, e, o, u, i 
 
Examples: 
countVowels("Hello")       -> 2 
countVowels("JavaScript is fun")    -> 5 
countVowels("")         -> 0 
 www.techglobalschool.com 
 
  27 
Reverse String Words 
Write a function named as reverseStringWords() which takes a string as an argument and 
returns string back with each word separately reversed when invoked. 
NOTE: Make your code dynamic that works for any string. Make sure you consider extra spaces 
before and after words in the given string. 
 
Examples: 
reverseStringWords("Hello World")      -> "olleH dlroW" 
reverseStringWords("I like JavaScript")     -> "I ekil tpircSavaJ" 
reverseStringWords("Hello")       -> "olleH" 
reverseStringWords("")         -> "" 
reverseStringWords(" ")         -> "" 
 
 
Count Consonants 
Write a function named as countConsonants() which takes a string word as an argument and 
returns the count of the consonant letters when invoked. 
NOTE: A letter that is not vowel is considered as a consonant letter. 
 
Examples: 
countConsonants("Hello")         -> 3 
countConsonants("Hello World")       -> 8 
countConsonants("JavaScript is fun")     -> 12 
countConsonants("")         -> 0 
 
 
 
Count Multiple Words 
Write a function named as countMultipleWords() which takes an array as an argument and 
returns the count of the elements that has multiple words when invoked. 
NOTE: Be careful about the extra whitespaces before and after the array element. 
 
Examples: 
countMultipleWords([ "foo", "", "  ", "foo bar", "   foo" ])     -> 1 
countMultipleWords([ "foo", "bar", "foobar", "   foobar   " ])     -> 0 
countMultipleWords([ "f o o", "b a r", "foo bar", "     foo bar   " ])     -> 4 
countMultipleWords([ ])               -> 0 
 
 www.techglobalschool.com 
 
  28 
FizzBuzz 
Write a function named as fizzBuzz() which takes 2 number arguments and returns a string 
composed with below requirements when invoked. 
•  You need to find all the numbers within the range of given 2 numbers (both inclusive) 
and store them in a string from smallest to greatest number with a ' | ' separator for each 
number. 
•  You will need to convert numbers divisible by 3 to 'Fizz' 
•  You will need to convert numbers divisible by 5 to 'Buzz' 
•  You will need to convert numbers divisible by both 3 and 5 to 'FizzBuzz’ 
•  The rest will stay the same. 
NOTE: Make your code dynamic that works for any numbers. 
Assume you will not be given negative numbers. 
 
Examples: 
fizzBuzz(13, 18)    -> "13 | 14 | FizzBuzz | 16 | 17 | Fizz" 
fizzBuzz(12, 5)    -> "Buzz | Fizz | 7 | 8 | Fizz | Buzz | 11 | Fizz" 
fizzBuzz(5, 5)    -> "Buzz" 
fizzBuzz(9, 6)    -> "Fizz | 7 | 8 | Fizz" 
 
 
Palindrome 
Write a function named as isPalindrome() which takes a string word as an argument and 
returns true if the word is palindrome or returns false otherwise when invoked. 
NOTE: Palindrome: It is a word that is read the same backward as forward 
Examples: kayak, civic, madam 
NOTE: your function should ignore case sensitivity 
 
Examples: 
isPalindrome("Hello")   -> false 
isPalindrome("Kayak")   -> true 
isPalindrome("civic")   -> true 
isPalindrome("abba")   -> true 
isPalindrome("ab  a")   -> false 
isPalindrome("123454321")   -> true 
isPalindrome("A")   -> true 
isPalindrome("")   -> true 
 
 
 
 www.techglobalschool.com 
 
  29 
Prime Number 
Write a function named as isPrime() which takes a number as an argument and returns true if 
the number is prime or returns false otherwise when invoked. 
NOTE: Mathematically, Prime number is a number that can be divided only by itself and 1. It 
cannot be divided by any other number. The smallest prime number is 2 and 2 is the only even 
prime number. 
Examples: 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31... 
NOTE: The smallest prime number is 2 and there is no negative prime numbers. 
 
Examples: 
isPrime(5)   -> true 
isPrime(2)   -> true 
isPrime(29)   -> true 
isPrime(-5)  -> false 
isPrime(0)  -> false 
isPrime(1)  -> false 
 
 
Add Two Arrays 
Write a function named add() which takes two array of numbers as argument and returns a new 
array with sum of given arrays elements. 
NOTE: Be careful about the array sizes as they could be different. 
 
Examples: 
add([3, 0, 0, 7, 5, 10], [6, 3, 2])         -> [9, 3, 2, 7, 5, 10] 
add([10, 3, 6, 3, 2], [6, 8, 3, 0, 0, 7, 5, 10, 34])     -> [16, 11, 9,  3, 2, 7, 5, 10, 34] 
add([-5, 6, -3, 11], [5, -6, 3, -11])         -> [0, 0, 0, 0] 
 
 
No Elements With A 
Write a function named noA() which takes an array of strings as argument and will return a 
new array with all elements starting with "A" or "a" replaced with "###". 
 
Examples: 
noA(["javascript", "hello", "123", "xyz"])     ->  ["javascript", "hello", "123", "xyz"] 
noA(["apple", "123", "ABC", "javascript"])     ->  ["###", "123", "###", "javascript"] 
noA(["apple", "abc", "ABC", "Alex", "A"])     ->  ["###", "###", "###", "###", "###"] 
 
 
 www.techglobalschool.com 
 
  30 
No Elements Divisible By 3 and 5 
Write a function named no3and5() which takes an array of integer numbers as argument and 
will return a new array with elements replaced by conditions below. 
If element can be divided by 5, replace it with 99 
If element can be divided by 3, replace it with 100 
If element can be divided by both 3 and 5, replace it with 101 
 
Examples: 
no3and5([7, 4, 11, 23, 17])       -> [7, 4, 11, 23, 17] 
no3and5([3, 4, 5, 6])       -> [100, 4, 99, 100] 
no3and5([10, 11, 12, 13, 14, 15])     -> [99, 11, 100, 13, 14, 101] 
 
 
No Elements Equals 13 
Write a function named no13() which takes an array of numbers as argument and return a new 
array with all 13s replaced with 0s.  
 
Examples: 
no13([1, 2, 3 ,4])       -> [1, 2, 3 ,4]  
no13([13, 2, 3])       -> [0, 2, 3] 
no13([13, 13, 13 , 13, 13])     -> [0, 0, 0, 0, 0] 
no13([])         -> [] 
 
 
Remove Duplicates 
Write a function named removeDuplicates() which takes an array argument and returns a new 
array with all the duplicates removed. 
 
Examples: 
removeDuplicates([10, 20, 35, 20, 35, 60, 70, 60])      -> [10, 20, 35, 60, 70] 
removeDuplicates([1, 2, 5, 2, 3])           -> [1, 2, 5, 3] 
removeDuplicates([0, -1, -2, -2, -1])         -> [0, -1, -2] 
removeDuplicates(["abc", "xyz", "123", "ab", "abc", "ABC"]) -> ["abc", "xyz", "123", "ab", "ABC"] 
removeDuplicates(["1", "2", "3", "2", "3"])         -> ["1", "2", "3"] 
 
 
 
 www.techglobalschool.com 
 
  31 
No Digits 
Write a function named noDigit() which takes a string argument and returns a new string with 
all digits removed from the original string. 
 
Examples: 
noDigit("")           -> "" 
noDigit("Javascript")       -> "Javascript" 
noDigit("123Hello")         -> "Hello" 
noDigit("123Hello World149")     -> "Hello World” 
noDigit("123Tech456Global149")     -> "TechGlobal" 
 
 
No Vowel 
Write a function named noVowel() which takes a string argument and returns a new string 
with all vowels removed from the original string. 
 
Examples: 
noVowel("TechGlobal")   -> "TchGlbl" 
noVowel("AEOxyz")   -> "xyz" 
noVowel("Javascript")   -> "Jvscrpt" 
noVowel("")   -> "" 
noVowel("125$")   -> "125$" 
 
 
Sum Of Digits 
Write a function named sumOfDigits() which takes a string argument and returns sum of all 
digits from the original string.  
 
Examples: 
sumOfDigits("Javascript")       -> 0 
sumOfDigits("John’s age is 29")     -> 11 
sumOfDigits("$125.0")       -> 8 
sumOfDigits("")         -> 0 
 
 
 
 
 www.techglobalschool.com 
 
  32 
Array Factorial 
Write a function named arrFactorial() which takes an array of numbers as argument and return 
the array with every number replaced with their factorials. 
 
Examples: 
arrFactorial([1, 2, 3 ,4])     -> [1, 2, 6, 24] 
arrFactorial([0, 5])       -> [1,120] 
arrFactorial([5 , 0, 6])     -> [120, 1, 720] 
arrFactorial([])       -> []











































































































































